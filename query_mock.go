package gockle

import (
	"context"
	"github.com/gocql/gocql"
	"github.com/stretchr/testify/mock"
)

// Query is an autogenerated mock type for the Query type
type QueryMock struct {
	mock.Mock
}

// Consistency provides a mock function with given fields: c
func (_m *QueryMock) Consistency(c gocql.Consistency) Query {
	ret := _m.Called(c)

	var r0 Query
	if rf, ok := ret.Get(0).(func(gocql.Consistency) Query); ok {
		r0 = rf(c)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Query)
		}
	}

	return r0
}

// Exec provides a mock function with given fields:
func (_m *QueryMock) Exec() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Iter provides a mock function with given fields:
func (_m *QueryMock) Iter() Iterator {
	ret := _m.Called()

	var r0 Iterator
	if rf, ok := ret.Get(0).(func() Iterator); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Iterator)
		}
	}

	return r0
}

// MapScan provides a mock function with given fields: m
func (_m *QueryMock) MapScan(m map[string]interface{}) error {
	ret := _m.Called(m)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) error); ok {
		r0 = rf(m)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PageSize provides a mock function with given fields: n
func (_m *QueryMock) PageSize(n int) Query {
	ret := _m.Called(n)

	var r0 Query
	if rf, ok := ret.Get(0).(func(int) Query); ok {
		r0 = rf(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Query)
		}
	}

	return r0
}

// PageState provides a mock function with given fields: state
func (_m *QueryMock) PageState(state []byte) Query {
	ret := _m.Called(state)

	var r0 Query
	if rf, ok := ret.Get(0).(func([]byte) Query); ok {
		r0 = rf(state)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Query)
		}
	}

	return r0
}

// Release provides a mock function with given fields:
func (_m *QueryMock) Release() {
	_m.Called()
}

// Scan provides a mock function with given fields: dest
func (_m *QueryMock) Scan(dest ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...interface{}) error); ok {
		r0 = rf(dest...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WithContext provides a mock function with given fields: ctx
func (_m *QueryMock) WithContext(ctx context.Context) Query {
	ret := _m.Called(ctx)

	var r0 Query
	if rf, ok := ret.Get(0).(func(context.Context) Query); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Query)
		}
	}

	return r0
}

